<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fbox basic</title>
</head>
<style>
  kbd {
    border: 1px solid gray;
    padding: .25rem;
    border-radius: .25rem;
  }

  dfn {
    font-style: normal;
  }

  ul {
    padding: 0;
    list-style: none;
  }

  [role="treeitem"] {
    border: 1px solid transparent;
  }

  [role="treeitem"]:focus {
    border: 1px solid black;
  }

  [role="treeitem"][aria-selected="true"] {
    border: 1px solid blue;
  }

  .t {
    color: initial;
  }

  .k {
    color: initial;
  }
</style>
<script type="module">
  import { render, html } from "https://cdn.skypack.dev/pin/uhtml@v2.2.2-NCNWbAlfOH9s1rfcepA9/min/uhtml.js"

  const RECORD = "record"
  const LIST = "list"
  const TUPLE = "tuple"
  const STRING = "string"
  const NUMBER = "number"
  const INTEGER = "integer"
  const BOOLEAN = "boolean"
  const NULL = "null"
  const UNION = "union"
  const ANY = "any"
  const REF = "ref"
  const VALUE = "value"
  const CONTAINER_TYPES = [RECORD, TUPLE, LIST, UNION]

  const anySch = () => ({ type: ANY })
  const stringSch = () => ({ type: STRING })
  const boolSch = () => ({ type: BOOLEAN })
  const numberSch = () => ({ type: NUMBER })
  const nullSch = () => ({ type: NULL })
  const recordSch = () => ({ type: RECORD, fields: {}, order: [] })
  const listSch = () => ({ type: LIST, sch: anySch() })
  const tupleSch = () => ({ type: TUPLE, schs: [stringSch(), boolSch(), numberSch()] })
  const unionSch = () => ({ type: UNION, schs: [nullSch(), recordSch(), numberSch()] })
  const schs = [anySch, stringSch, boolSch, numberSch, nullSch, recordSch, listSch, tupleSch, unionSch]

  var store = recordSch()

  const walk = (sch, f, meta = {}) => {
    meta.path = meta.path || ""
    meta.level = meta.level || 0

    switch (true) {
      case [RECORD].includes(sch.type):
        for (let [k, sch_] of Object.entries(sch.fields)) {
          let nextMeta = { path: `${meta.path}[${k}]`, level: meta.level + 1 }
          sch.fields[k] = walk(sch_, f, nextMeta)
        }
        break
      case [TUPLE, UNION].includes(sch.type):
        sch.schs.forEach((sch_, i) => {
          let nextMeta = { path: `${meta.path}[][${i}]`, level: meta.level + 1 }
          sch.schs[i] = walk(sch_, f, nextMeta)
        })
        break
      case [LIST].includes(sch.type):
        let nextMeta = { path: `${meta.path}[][0]`, level: meta.level + 1 }
        sch.sch = walk(sch.sch, f, nextMeta)
        break
      default:
        sch
    }

    return f(sch, meta)
  }

  const popSchs = (schema, path, indices) => {
    let result = { original: { ...schema }, popped: {} }
    let descIndices = indices.sort((a, b) => b - a)

    walk(schema, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case RECORD:
            let keys = descIndices.map((i_) => sch_.order[i_])

            for (let k of keys) { result.popped[k] = sch_.fields[k]; delete sch_.fields[k] }
            for (let i of descIndices) sch_.order.splice(i, 1)

            break
          case LIST:
            break
          case TUPLE:
            for (let i of descIndices) sch_.schs.splice(i, 1)
            break
          case UNION:
            for (let i of descIndices) sch_.schs.splice(i, 1)
            break
          default:
            sch_
        }
        return sch_
      }
    })

    return result
  }

  const putSch = (currentNode, path, k, sch, index) => {
    walk(currentNode, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case RECORD:
            k = `key_${k || Date.now() / 100}`
            while (sch_.fields[k]) k = `${k} (copy)`

            sch_.fields[k] = sch()
            sch_.order.unshift(k)

            break
          case LIST:
            break
          case TUPLE:
            sch_.schs.unshift(sch())
            break
          case UNION:
            sch_.schs.unshift(sch())
            break
          default:
            sch_
        }
        return sch_
      }
    })
  }

  const getSch = (currentNode, path) => {
    let foundSch
    walk(currentNode, (sch_, meta) => {
      if (meta.path == path) return foundSch = sch_
      else return sch_
    })
    return foundSch && { ...foundSch }
  }

  const renderRoot = (sch) =>
    viewMain({ sch: sch, ui: { level: 1, tab: 1.5 }, path: "", key: "root" })

  const viewMain = (assigns) =>
    render(document.body, html`
      <p>Press <kbd>shift</kbd> + <kbd>+</kbd> to add random schema to container types (record | union | tuple)</p>
      <p>Press <kbd>ArrowUp</kbd> / <kbd>ArrowUp</kbd> to select schema</p>
      <p>Press <kbd>shift</kbd> + <kbd>ArrowUp</kbd> / <kbd>ArrowUp</kbd> to mutiple select schema</p>
      <p>Press <kbd>Delete</kbd> to delete selected schema</p>

      <section style="display: flex; justify-content: space-around;">
        <ul role="tree" aria-multiselectable="true">
          ${viewModel(assigns)}
        </ul>
        <pre><code>${JSON.stringify(store, null, '  ')}</code></pre>
      </section>
    `)

  const viewModel = (assigns) =>
    CONTAINER_TYPES.includes(assigns.sch.type) ? viewFolder(assigns) : viewFile(assigns)

  const viewFolder = (assigns) =>
    html.for(assigns.sch)`<li id="${assigns.path}" class="sort-handle" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
      <dfn class="h">
        ${viewKey({ ...assigns, key: wordBreakHtml(assigns.key) })}
        ${viewType(assigns)}
      </dfn>
      <ul data-group="${keyedOrIndexed(assigns.sch)}" role="group">
        ${viewItself(assigns)}
      </ul>
    </li>`

  const viewFile = (assigns) =>
    html.for(assigns.sch)`<li id="${assigns.path}" class="sort-handle flex" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
      ${viewKey({ ...assigns, key: wordBreakHtml(assigns.key) })}
      ${viewType(assigns)}
    </li>`

  const viewItself = (assigns) => {
    switch (true) {
      case [RECORD].includes(assigns.sch.type):
        return viewKeyed(assigns)
        break
      case [TUPLE].includes(assigns.sch.type):
        return viewIndexed(assigns)
        break
      case [LIST].includes(assigns.sch.type):
        return viewSingled(assigns)
        break
      case [UNION].includes(assigns.sch.type):
        return viewNonKeyed(assigns)
        break
      default:
        return html``
    }
  }

  const viewKeyed = (assigns) =>
    assigns.sch.order.map(k =>
      viewModel({
        key: k,
        sch: assigns.sch.fields[k],
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[${k}]`
      })
    )

  const viewIndexed = (assigns) =>
    assigns.sch.schs.map((sch, i) =>
      viewModel({
        key: i,
        sch: assigns.sch.schs[i],
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[][${i}]`
      })
    )

  const viewSingled = (assigns) =>
    viewModel({
      key: 0,
      sch: assigns.sch.sch,
      parent: { type: assigns.sch.type, path: assigns.path },
      ui: { ...assigns.ui, level: assigns.ui.level + 1 },
      path: `${assigns.path}[][${0}]`
    })

  const viewNonKeyed = (assigns) =>
    assigns.sch.schs.map((sch, i) =>
      viewModel({
        key: "",
        sch: sch,
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[][${i}]`
      })
    )

  const indent = (assigns) => `padding-left: ${((assigns.ui.level - 1) * 1.25) + assigns.ui.tab}rem`
  const viewKey = (assigns) => assigns.ui.level == 1 ? viewKeyRoot(assigns) : viewKeyNonRoot(assigns)
  const viewKeyRoot = (assigns) =>
    html`
    <span class="text-blue-500 mr-2" style=${indent(assigns)}>
      ${modelTypeText(assigns.sch, assigns.ui)}
    </span>
    <sch-key class="k">${assigns.key}</sch-key>
    <span class="mx-2">=</span>
    `
  const viewKeyNonRoot = (assigns) => {
    switch (true) {
      case assigns.parent.type == UNION:
        return html`
          <span class="" style=${indent(assigns)}></span>
          <span class="mx-2 text-gray-500">|</span>
          `
        break
      case assigns.parent.type == LIST:
        return html`
          <span class="k" style=${indent(assigns)}></span>
          <span class="mx-2 text-gray-500">â””</span>
          `
        break
      default:
        return html`
          <span class="k" style=${indent(assigns)}>${assigns.key}</span>
          <span class="mx-2 text-gray-500">:</span>
          `
    }
  }

  const viewType = (assigns) => assigns.level == 1 ? viewTypeRoot(assigns) : viewTypeNonRoot(assigns)
  const viewTypeRoot = (assigns) =>
    html`<span class="t text-pink-400" role="complementary">${typeText(assigns.sch, assigns.ui)}</span>`
  const viewTypeNonRoot = (assigns) =>
    html`<span class="t text-pink-400" role="complementary">${typeText(assigns.sch, assigns.ui)}</span>`

  const typeText = (sch, ui) => {
    switch (true) {
      case sch.type == RECORD && jEQ(sch.fields, {}): return "{ any }"
      case sch.type == RECORD: return `{ \xa0 }`
      case sch.type == LIST && sch.sch.type == "any": return "[ any ]"
      case sch.type == LIST: return `${typeText(sch.sch, ui)}`
      case sch.type == TUPLE: return "( \xa0 )"
      case sch.type == STRING: return "string"
      case sch.type == NUMBER: return "number"
      case sch.type == INTEGER: return "integer"
      case sch.type == BOOLEAN: return "bool"
      case sch.type == NULL: return "null"
      case sch.type == UNION: return "||"
      case sch.type == ANY: return "any"
      case sch.type == REF: return "ref"
      case sch.type == VALUE: return "value"
      default: return "please define what type ${sch} is"
    }
  }

  const wordBreakHtml = (word) => word
  const keyedOrIndexed = (assigns) => "keyed"

  const modelTypeText = (sch, ui) => {
    switch (true) {
      case sch.type == RECORD: return "record"; break
      case sch.type == LIST: return "list"; break
      case sch.type == TUPLE: return "tuple"; break
      case sch.type == UNION: return "union"; break
      default: return "field"
    }
  }

  const selectedGroupedByParents = (tree) =>
    [...tree.querySelectorAll("[aria-selected='true']")].reduce((acc, child) => {
      let parent = child.parentNode.closest("[role='treeitem']")
      if (!parent) return acc

      let parentLevel = parseInt(parent.getAttribute("aria-level"))
      let children = parent.querySelectorAll(`[aria-level='${parentLevel + 1}'][role='treeitem']`)

      acc[parent.id] = acc[parent.id] || []
      acc[parent.id].push([...children].indexOf(child))
      return acc
    }, {})

  const deleteSelected = (tree) => {
    const indicesPerParent = selectedGroupedByParents(tree)

    for (let parentPath of Object.keys(indicesPerParent))
      popSchs(store, parentPath, indicesPerParent[parentPath])
  }

  const selectNode = (tree, currentNode, nextStepNode) => {
    if (nextStepNode) {
      deselectAllNode(tree, currentNode)
      selectMultiNode(nextStepNode)
    }
  }
  const deselectAllNode = (tree, currentNode) => {
    [...tree.querySelectorAll("[aria-selected='true']")]
      .forEach(item => item.setAttribute("aria-selected", false))
    currentNode.tabIndex = -1
    currentNode.setAttribute("aria-selected", false)
  }
  const selectMultiNode = (nextStepNode) => {
    if (nextStepNode) {
      nextStepNode.setAttribute("aria-selected", true)
      nextStepNode.tabIndex = 0
      nextStepNode.focus()
    }
  }

  const findUnselectedNode = (fstep, nextNode) => {
    do nextNode = fstep()
    while (nextNode?.getAttribute("aria-selected") == "true")
    return nextNode
  }

  function handleTreeKeydown(e) {
    let tree = this
    let currentNode = tree._walker.currentNode

    switch (e.code) {
      case "ArrowUp":
        e.shiftKey ?
          selectMultiNode(tree._walker.previousSibling()) :
          selectNode(tree, currentNode, tree._walker.previousNode())
        break
      case "ArrowDown":
        e.shiftKey ?
          selectMultiNode(tree._walker.nextSibling()) :
          selectNode(tree, currentNode, tree._walker.nextNode())
        break
      case "Delete":
        let nextNode =
          findUnselectedNode(() => tree._walker.nextSibling()) ||
          findUnselectedNode(() => tree._walker.previousSibling()) ||
          findUnselectedNode(() => tree._walker.parentNode())

        deleteSelected(tree)
        renderRoot(store)
        selectNode(tree, currentNode, nextNode)
      default:
        switch (e.key) {
          case "+":
            putSch(store, currentNode.id, null, schs[ranInt(schs.length)], -1)
            renderRoot(store)
            break
        }
    }

    e.preventDefault()
  }

  function handleTreeClick(e) {
    let tree = this
    let prevtNode = tree._walker.currentNode
    tree._walker.currentNode = e.target.closest("[role='treeitem']")
    selectNode(tree, prevtNode, tree._walker.currentNode)
  }

  const ranInt = max => Math.floor(Math.random() * Math.floor(max));
  const jEQ = (obj1, obj2) => JSON.stringify(obj1) == JSON.stringify(obj2)

  window.addEventListener("DOMContentLoaded", e => {
    document.querySelectorAll("[role='tree']").forEach(tree => {
      tree._walker = document.createTreeWalker(
        tree,
        NodeFilter.SHOW_ELEMENT,
        {
          acceptNode: function (node) {
            if (node.hasAttribute("aria-selected")) return NodeFilter.FILTER_ACCEPT
            else return NodeFilter.FILTER_SKIP
          }
        },
        false
      )
      tree.onkeydown = handleTreeKeydown
      tree.onclick = handleTreeClick

      let firstNode = tree._walker.nextNode()
      selectNode(tree, firstNode, firstNode)
    })
  })
  renderRoot(store)
</script>

<body>
</body>

</html>
