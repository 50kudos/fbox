<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fbox basic</title>
</head>
<style>
  kbd {
    border: 1px solid gray;
    padding: .25rem;
    border-radius: .25rem;
  }
</style>
<script type="module">
  import { render, html } from "https://cdn.skypack.dev/uhtml"

  const anySch = () => ({ type: "any" })
  const stringSch = () => ({ type: "string" })
  const boolSch = () => ({ type: "boolean" })
  const numberSch = () => ({ type: "number" })
  const nullSch = () => ({ type: "null" })
  const recordSch = () => ({ type: "record", fields: {}, order: [] })
  const listSch = () => ({ type: "list", sch: anySch() })
  const tupleSch = () => ({ type: "tuple", schs: [stringSch(), boolSch(), numberSch()] })
  const unionSch = () => ({ type: "union", schs: [nullSch(), recordSch(), numberSch()] })
  const schs = [anySch, stringSch, boolSch, numberSch, nullSch, recordSch, listSch, tupleSch, unionSch]

  var store = recordSch()

  const walk = (sch, f, meta = {}) => {
    meta.path = meta.path || ""
    meta.level = meta.level || 0

    switch (true) {
      case ["record"].includes(sch.type):
        for (let [k, sch_] of Object.entries(sch.fields)) {
          let nextMeta = { path: `${meta.path}[${k}]`, level: meta.level + 1 }
          sch.fields[k] = walk(f(sch_, nextMeta), f, nextMeta)
        }
        break
      case ["tuple", "union"].includes(sch.type):
        sch.schs.forEach((sch_, i) => {
          let nextMeta = { path: `${meta.path}[][${i}]`, level: meta.level + 1 }
          sch.schs[i] = walk(f(sch_, nextMeta), f, nextMeta)
        })
        break
      case ["list"].includes(sch.type):
        let nextMeta = { path: `${meta.path}[][0]`, level: meta.level + 1 }
        sch.sch = walk(f(sch.sch, nextMeta), f, nextMeta)
        break
      default:
        sch
    }

    return f(sch, meta)
  }
  const putSch = (currentNode, path, k, sch, index) => {
    walk(currentNode, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case "record":
            k = k || Date.now()
            sch_.fields[k] = sch()
            sch_.order.push(k)
            break
          case "list":
            break
          case "tuple":
            sch_.schs.unshift(sch())
            break
          case "union":
            sch_.schs.unshift(sch())
            break
          default:
            sch_
        }
        return sch_
      }
    })
  }

  const renderHtml = (store) => {
    render(document.body, html`
      <p>Press <kbd>shift</kbd> + <kbd>+</kbd> to add random schema</p>
      <pre><code>${JSON.stringify(store, null, '  ')}</code></pre>
      `)
  }

  const handleKeydown = e => {
    let currentPath = ""
    switch (e.key) {
      case "+":
        putSch(store, currentPath, null, schs[ranInt(schs.length - 1)], -1)
        renderHtml(store)
        break
    }
  }

  const ranInt = max => Math.floor(Math.random() * Math.floor(max));

  document.addEventListener("keydown", handleKeydown)
  renderHtml(store)
</script>

<body>
</body>

</html>
