<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fbox basic</title>
</head>
<style>
  kbd {
    border: 1px solid gray;
    padding: .25rem;
    border-radius: .25rem;
  }

  dfn {
    font-style: normal;
  }

  ul {
    padding: 0;
    list-style: none;
  }

  @keyframes fadein {
    from {
      opacity: 0;
    }

    to {
      opacity: 1;
    }
  }

  [role="treeitem"] {
    border: 1px solid transparent;
  }

  [role="treeitem"][aria-selected="true"] {
    border: 1px solid black;
  }

  [role="treeitem"][aria-selected="true"]:focus {
    border: 1px solid blue;
  }

  [role="treeitem"].item-cutting {
    border: 1px solid orange;
  }

  [role="treeitem"].item-pasted {
    animation: fadein;
    animation-duration: .25s;
  }

  .t {
    color: initial;
  }

  .k {
    color: initial;
  }
</style>
<script type="module">
  import { render, html } from "https://cdn.skypack.dev/pin/uhtml@v2.2.2-NCNWbAlfOH9s1rfcepA9/min/uhtml.js"

  const RECORD = "record"
  const LIST = "list"
  const TUPLE = "tuple"
  const STRING = "string"
  const NUMBER = "number"
  const INTEGER = "integer"
  const BOOLEAN = "boolean"
  const NULL = "null"
  const UNION = "union"
  const ANY = "any"
  const REF = "ref"
  const VALUE = "value"
  const CONTAINER_TYPES = [RECORD, TUPLE, LIST, UNION]

  const anySch = () => ({ type: ANY })
  const stringSch = () => ({ type: STRING })
  const boolSch = () => ({ type: BOOLEAN })
  const numberSch = () => ({ type: NUMBER })
  const nullSch = () => ({ type: NULL })
  const recordSch = () => ({ type: RECORD, fields: {}, order: [] })
  const listSch = () => ({ type: LIST, sch: anySch() })
  const tupleSch = () => ({ type: TUPLE, schs: [stringSch(), boolSch(), numberSch()] })
  const unionSch = () => ({ type: UNION, schs: [nullSch(), recordSch(), numberSch()] })
  const schs = [anySch, stringSch, boolSch, numberSch, nullSch, recordSch, listSch, tupleSch, unionSch]

  var store = recordSch()
  const copyObj = (obj) => JSON.parse(JSON.stringify(obj))

  const walk = (sch, f, meta = {}) => {
    meta.path = meta.path || ""
    meta.level = meta.level || 0

    switch (true) {
      case [RECORD].includes(sch.type):
        for (let [k, sch_] of Object.entries(sch.fields)) {
          let nextMeta = { path: `${meta.path}[${k}]`, level: meta.level + 1 }
          sch.fields[k] = walk(sch_, f, nextMeta)
        }
        break
      case [TUPLE, UNION].includes(sch.type):
        sch.schs.forEach((sch_, i) => {
          let nextMeta = { path: `${meta.path}[][${i}]`, level: meta.level + 1 }
          sch.schs[i] = walk(sch_, f, nextMeta)
        })
        break
      case [LIST].includes(sch.type):
        let nextMeta = { path: `${meta.path}[][0]`, level: meta.level + 1 }
        sch.sch = walk(sch.sch, f, nextMeta)
        break
      default:
        sch
    }

    return f(sch, meta)
  }

  const popSchs = (schema, path, indices) => {
    let result = { original: copyObj(schema), popped: [] }
    let descIndices = indices.sort((a, b) => b - a)

    walk(schema, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case RECORD:
            let keys = descIndices.map((i_) => sch_.order[i_]).filter((i_) => i_)

            for (let k of keys) { result.popped.unshift([k, sch_.fields[k]]); delete sch_.fields[k] }
            for (let i of descIndices) sch_.order.splice(i, 1)

            break
          case LIST:
            break
          case TUPLE:
            for (let i of descIndices) result.popped.unshift([i, sch_.schs.splice(i, 1)[0]])
            break
          case UNION:
            for (let i of descIndices) result.popped.unshift([i, sch_.schs.splice(i, 1)[0]])
            break
          default:
            sch_
        }
        return sch_
      }
    })

    return result
  }

  const putSchs = (currentNode, path, rawSchs) => {
    let ascRawSchs = rawSchs.sort((a, b) => a.index - b.index)

    walk(currentNode, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case RECORD:
            for (let { k, sch, index } of ascRawSchs) {
              k = k == 0 ? "0" : k
              k = k || `key_${Date.now() / 100}`
              while (sch_.fields[k]) k = `${k} (copy)`

              sch_.fields[k] = sch()
              sch_.order.splice(index, 0, k)
            }

            break
          case LIST:
            break
          case TUPLE:
            for (let { k, sch, index } of ascRawSchs)
              sch_.schs.splice(index, 0, sch())
            break
          case UNION:
            for (let { k, sch, index } of ascRawSchs)
              sch_.schs.splice(index, 0, sch())
            break
          default:
            sch_
        }
        return sch_
      }
    })
  }

  const moveSchs = (store, dstPath, selectedPerParent) => {
    const pinDst = (store, dstPath, pin) =>
      getAndUpdateSch(store, (a, m) => m.path == dstPath, (a, m) => { a._pinId = pin; return a })

    const getPinedDst = (store, pin) =>
      getAndUpdateSch(store, (a, m) => a._pinId == pin, (a, m) => { a._pinned = m; return a })

    const srcPaths = filterMostOuters(Object.keys(selectedPerParent))
    let moved = {}

    for (let srcPath of srcPaths) {
      let selectedItems = selectedPerParent[srcPath]
      let isDstSubtree = selectedItems.filter(c => dstPath.startsWith(c.id)).length != 0

      if (!isDstSubtree) {
        let pin = Symbol(srcPath)
        pinDst(store, dstPath, pin)

        let result = popSchs(store, srcPath, selectedItems.map(c => c.index))
        let rawSchs = result.popped.map(([k, sch], i) => ({ k: k, sch: () => sch, index: i }))

        let dst = getPinedDst(store, pin)
        putSchs(store, dst._pinned.path, rawSchs)

        moved[dst._pinned.path] = rawSchs
      }
    }

    return moved
  }

  const getSch = (currentNode, path) =>
    getSchBy(currentNode, (a, m) => m.path == path)

  const getSchBy = (currentNode, fget) =>
    getAndUpdateSch(currentNode, fget, (a, m) => a)

  const getAndUpdateSch = (currentNode, fget, fupdate) => {
    let foundSch
    walk(currentNode, (sch_, meta) => {
      if (fget(sch_, meta)) return foundSch = fupdate(sch_, meta)
      else return sch_
    })
    return foundSch && { ...foundSch }
  }

  const renderRoot = (sch) =>
    viewMain({ sch: sch, ui: { level: 1, tab: 1.5 }, path: "", key: "root" })

  const viewMain = (assigns) =>
    render(document.body, html`
      <h3>Add</h3>
      <p>Press <kbd>shift</kbd> + <kbd>+</kbd> to add random schema to container types (record | union | tuple)</p>
      <h3>Select</h3>
      <p>Press <kbd>ArrowUp</kbd> / <kbd>ArrowUp</kbd> to select schema</p>
      <p>Press <kbd>shift</kbd> + <kbd>ArrowUp</kbd> / <kbd>ArrowUp</kbd> to mutiple select schema</p>
      <h3>Delete</h3>
      <p>Press <kbd>Delete</kbd> to delete selected schema</p>
      <h3>Move</h3>
      <p>Press <kbd>cmd</kbd> + <kbd>x</kbd> to cut selected schema</p>
      <p>Press <kbd>cmd</kbd> + <kbd>v</kbd> to paste schema from (cmd + x) command</p>

      <section style="display: flex; justify-content: space-around;">
        <ul role="tree" aria-multiselectable="true">
          ${viewModel(assigns)}
        </ul>
        <pre><code>${JSON.stringify(store, null, '  ')}</code></pre>
      </section>
    `)

  const viewModel = (assigns) =>
    CONTAINER_TYPES.includes(assigns.sch.type) ? viewFolder(assigns) : viewFile(assigns)

  const viewFolder = (assigns) =>
    html`<li id="${assigns.path}" class="sort-handle" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
      <dfn class="h">
        ${viewKey({ ...assigns, key: wordBreakHtml(assigns.key) })}
        ${viewType(assigns)}
      </dfn>
      <ul data-group="${keyedOrIndexed(assigns.sch)}" role="group">
        ${viewItself(assigns)}
      </ul>
    </li>`

  const viewFile = (assigns) =>
    html`<li id="${assigns.path}" class="sort-handle flex" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
      ${viewKey({ ...assigns, key: wordBreakHtml(assigns.key) })}
      ${viewType(assigns)}
    </li>`

  const viewItself = (assigns) => {
    switch (true) {
      case [RECORD].includes(assigns.sch.type):
        return viewKeyed(assigns)
        break
      case [TUPLE].includes(assigns.sch.type):
        return viewIndexed(assigns)
        break
      case [LIST].includes(assigns.sch.type):
        return viewSingled(assigns)
        break
      case [UNION].includes(assigns.sch.type):
        return viewNonKeyed(assigns)
        break
      default:
        return html``
    }
  }

  const viewKeyed = (assigns) =>
    assigns.sch.order.map(k =>
      viewModel({
        key: k,
        sch: assigns.sch.fields[k],
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[${k}]`
      })
    )

  const viewIndexed = (assigns) =>
    assigns.sch.schs.map((sch, i) =>
      viewModel({
        key: i,
        sch: assigns.sch.schs[i],
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[][${i}]`
      })
    )

  const viewSingled = (assigns) =>
    viewModel({
      key: 0,
      sch: assigns.sch.sch,
      parent: { type: assigns.sch.type, path: assigns.path },
      ui: { ...assigns.ui, level: assigns.ui.level + 1 },
      path: `${assigns.path}[][${0}]`
    })

  const viewNonKeyed = (assigns) =>
    assigns.sch.schs.map((sch, i) =>
      viewModel({
        key: "",
        sch: sch,
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[][${i}]`
      })
    )

  const indent = (assigns) => `padding-left: ${((assigns.ui.level - 1) * 1.25) + assigns.ui.tab}rem`
  const viewKey = (assigns) => assigns.ui.level == 1 ? viewKeyRoot(assigns) : viewKeyNonRoot(assigns)
  const viewKeyRoot = (assigns) =>
    html`
    <span class="text-blue-500 mr-2" style=${indent(assigns)}>
      ${modelTypeText(assigns.sch, assigns.ui)}
    </span>
    <sch-key class="k">${assigns.key}</sch-key>
    <span class="mx-2">=</span>
    `
  const viewKeyNonRoot = (assigns) => {
    switch (true) {
      case assigns.parent.type == UNION:
        return html`
          <span class="" style=${indent(assigns)}></span>
          <span class="mx-2 text-gray-500">|</span>
          `
        break
      case assigns.parent.type == LIST:
        return html`
          <span class="k" style=${indent(assigns)}></span>
          <span class="mx-2 text-gray-500">└</span>
          `
        break
      default:
        return html`
          <span class="k" style=${indent(assigns)}>${assigns.key}</span>
          <span class="mx-2 text-gray-500">:</span>
          `
    }
  }

  const viewType = (assigns) => assigns.level == 1 ? viewTypeRoot(assigns) : viewTypeNonRoot(assigns)
  const viewTypeRoot = (assigns) =>
    html`<span class="t text-pink-400" role="complementary">${typeText(assigns.sch, assigns.ui)}</span>`
  const viewTypeNonRoot = (assigns) =>
    html`<span class="t text-pink-400" role="complementary">${typeText(assigns.sch, assigns.ui)}</span>`

  const typeText = (sch, ui) => {
    switch (true) {
      case sch.type == RECORD && jEQ(sch.fields, {}): return "{ any }"
      case sch.type == RECORD: return `{ \xa0 }`
      case sch.type == LIST && sch.sch.type == "any": return "[ any ]"
      case sch.type == LIST: return `${typeText(sch.sch, ui)}`
      case sch.type == TUPLE: return "( \xa0 )"
      case sch.type == STRING: return "string"
      case sch.type == NUMBER: return "number"
      case sch.type == INTEGER: return "integer"
      case sch.type == BOOLEAN: return "bool"
      case sch.type == NULL: return "null"
      case sch.type == UNION: return "||"
      case sch.type == ANY: return "any"
      case sch.type == REF: return "ref"
      case sch.type == VALUE: return "value"
      default: return "please define what type ${sch} is"
    }
  }

  const wordBreakHtml = (word) => word
  const keyedOrIndexed = (assigns) => "keyed"

  const modelTypeText = (sch, ui) => {
    switch (true) {
      case sch.type == RECORD: return "record"; break
      case sch.type == LIST: return "list"; break
      case sch.type == TUPLE: return "tuple"; break
      case sch.type == UNION: return "union"; break
      default: return "field"
    }
  }

  const selectedGroupedByParent = (tree, opts = {}) =>
    [...tree.querySelectorAll(`${opts.ops || "[aria-selected='true']"}`)].reduce((acc, child) => {
      let parent = child.parentNode.closest("[role='treeitem']")
      if (!parent) return acc

      let parentLevel = parseInt(parent.getAttribute("aria-level"))
      let children = parent.querySelectorAll(`[aria-level='${parentLevel + 1}'][role='treeitem']`)

      child.index = [...children].indexOf(child)
      acc[parent.id] = acc[parent.id] || []
      acc[parent.id].push(child)
      return acc
    }, {})

  const deleteSelected = (tree) => {
    const indicesPerParent = selectedGroupedByParent(tree)

    for (let parentPath of Object.keys(indicesPerParent))
      popSchs(store, parentPath, indicesPerParent[parentPath].map(c => c.index))
  }

  const selectNode = (tree, currentNode, nextStepNode) => {
    if (nextStepNode) {
      deselectAllNode(tree, currentNode)
      selectMultiNode(nextStepNode)
    }
  }
  const deselectAllNode = (tree, currentNode) => {
    [...tree.querySelectorAll("[aria-selected='true']")]
      .forEach(item => item.setAttribute("aria-selected", false))
    currentNode.tabIndex = -1
    currentNode.setAttribute("aria-selected", false)
  }
  const selectMultiNode = (nextStepNode) => {
    if (nextStepNode) {
      nextStepNode.setAttribute("aria-selected", true)
      nextStepNode.tabIndex = 0
      nextStepNode.focus()
    }
  }
  const findUnselectedNode = (fstep, nextNode) => {
    do nextNode = fstep()
    while (nextNode?.getAttribute("aria-selected") == "true")
    return nextNode
  }
  const reselectNodes = (tree, nodes) => {
    for (let newDst of Object.keys(nodes)) {
      let rawSchs = nodes[newDst]

      newDst = tree.querySelector(`[id='${newDst}']`)
      let dstLevel = parseInt(newDst.getAttribute("aria-level"))
      let children = newDst.querySelectorAll(`[aria-level='${dstLevel + 1}'][role='treeitem']`)

      deselectAllNode(tree, tree._walker.currentNode)
      rawSchs.map(({ index }) => children[index]).forEach(a => {
        a.classList.add("item-pasted")
        selectMultiNode(a)
        tree._walker.currentNode = a
      })
    }
  }

  const filterMostOuters = (paths) => {
    return paths.filter(p => {
      for (let p_ of paths) {
        if (p == p_) return true
        else if (p.startsWith(p_)) return false
      }
    })
  }

  const clearClipboard = (tree) => {
    tree.querySelectorAll(".item-cutting").forEach(a => a.classList.remove("item-cutting"))
    tree._clipboard = null
  }

  function handleTreeKeydown(e) {
    let tree = this
    let currentNode = tree._walker.currentNode

    switch (e.code) {
      case "ArrowUp":
        e.shiftKey ?
          selectMultiNode(tree._walker.previousSibling()) :
          selectNode(tree, currentNode, tree._walker.previousNode())
        break
      case "ArrowDown":
        e.shiftKey ?
          selectMultiNode(tree._walker.nextSibling()) :
          selectNode(tree, currentNode, tree._walker.nextNode())
        break
      case "Delete":
        let nextNode =
          findUnselectedNode(() => tree._walker.nextSibling()) ||
          findUnselectedNode(() => tree._walker.previousSibling()) ||
          findUnselectedNode(() => tree._walker.parentNode())

        deleteSelected(tree)
        renderRoot(store)
        selectNode(tree, currentNode, nextNode)
        break
      case "KeyX":
        if (e.metaKey) {
          clearClipboard(tree)

          tree._clipboard = () => selectedGroupedByParent(tree, { ops: ".item-cutting" })
          tree.querySelectorAll("[aria-selected='true']").forEach(a => a.classList.add("item-cutting"))
        }
        break
      case "KeyV":
        const dstSch = getSch(store, tree._walker.currentNode.id)
        if (![RECORD, UNION, TUPLE].includes(dstSch.type)) return

        if (e.metaKey && tree._clipboard) {
          const dstPath = tree._walker.currentNode.id
          const selectedPerParent = tree._clipboard()

          let moved = moveSchs(store, dstPath, selectedPerParent)
          renderRoot(store)
          clearClipboard(tree)
          reselectNodes(tree, moved)
        }
        break
      default:
        switch (e.key) {
          case "+":
            let randomSch = schs[ranInt(schs.length)]

            putSchs(store, currentNode.id, [{ k: null, sch: randomSch, index: 0 }])
            renderRoot(store)
            break
        }
    }

    e.preventDefault()
  }

  function handleTreeClick(e) {
    let tree = this
    let prevtNode = tree._walker.currentNode
    tree._walker.currentNode = e.target.closest("[role='treeitem']")
    selectNode(tree, prevtNode, tree._walker.currentNode)
  }

  const ranInt = max => Math.floor(Math.random() * Math.floor(max));
  const jEQ = (obj1, obj2) => JSON.stringify(obj1) == JSON.stringify(obj2)

  window.addEventListener("DOMContentLoaded", e => {
    document.querySelectorAll("[role='tree']").forEach(tree => {
      tree._walker = document.createTreeWalker(
        tree,
        NodeFilter.SHOW_ELEMENT,
        {
          acceptNode: function (node) {
            if (node.hasAttribute("aria-selected")) return NodeFilter.FILTER_ACCEPT
            else return NodeFilter.FILTER_SKIP
          }
        },
        false
      )
      tree.onkeydown = handleTreeKeydown
      tree.onclick = handleTreeClick

      let firstNode = tree._walker.nextNode()
      selectNode(tree, firstNode, firstNode)
    })
  })
  renderRoot(store)
</script>

<body>
</body>

</html>
